<!DOCTYPE html>
<html lang="de">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Adventskalender - Tür</title>
        <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;700&display=swap" rel="stylesheet">
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
    
            body {
                background: url('background.jpeg');
                background-size: cover;
                background-position: center center;
                background-repeat: no-repeat;
                background-attachment: fixed; /* Wichtig für Responsiveness */
                font-family: 'Mountains of Christmas', cursive;
                min-height: 100vh;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                padding: 20px;
                color: #ffffff;
                overflow-x: hidden;
            }
    
            .snow {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                pointer-events: none;
                z-index: 1;
            }
    
            .snowflake {
                position: absolute;
                background: white;
                border-radius: 50%;
                opacity: 0.8;
                animation: fall linear infinite;
            }
    
            @keyframes fall {
                to {
                    transform: translateY(100vh) rotate(720deg);
                }
            }
    
            .content {
                position: relative;
                z-index: 2;
                text-align: center;
                max-width: 800px;
                padding: 20px;
                background: rgba(0, 0, 0, 0.656);
                border-radius: 15px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            }
    
            h1 {
                color: #E0E7FF;
                font-size: 2em;
                font-weight: 700;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
                margin-bottom: 20px;
            }
    
            p {
                color: #c9ddf7;
                font-size: 1.2em;
                font-weight: 400;
                margin-bottom: 10px;
                text-align: left;
            }
    
            ul {
                color: #c9ddf7;
                font-size: 1em;
                font-weight: 400;
                margin-left: 40px;
                margin-bottom: 20px;
                text-align: left;
            }
    
            li {
                margin-bottom: 10px;
            }
    
            .navigation {
                display: flex;
                gap: 20px;
                justify-content: center;
                margin-top: 20px;
            }
    
            .nav-button {
                padding: 10px 20px;
                font-size: 1.2em;
                color: #E0E7FF;
                text-decoration: none;
                background: rgba(255, 255, 255, 0.2);
                border: none;
                border-radius: 10px;
                cursor: pointer;
                transition: all 0.3s ease;
            }
    
            .nav-button:hover {
                background: rgba(255, 255, 255, 0.5);
                transform: scale(1.05);
            }
    
            .nav-button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                transform: none;
            }
    
            .page {
                display: none;
            }
    
            .page.active {
                display: block;
            }
        </style>
<body>
    <div class="snow" id="snowContainer"></div>
    <div class="content">
        <div class="page active" data-page="1">
            <h1>Türchen 4: PFM</h1>
            <p>Heii :), das vierte Türchen geht um die "Positionsspezifische Häufigkeitsmatrix (PFM)". Wir haben jetzt mehrere Sequenzen gegeben und wollen herausfinden wie oft die Basen an jeder Position vorkommen. Um einfach zu starten können wir diese 4 Sequenzen nehmen:</p>
            <pre>
sequences = c("ATA", "CTG", "GTG", "TTA")

print(sequences)
            </pre>

            <p>Zuerst müssen wir die Sequenzen/String am besten jeweils aufsplitten damit wir besser mit ihnen arbeiten können.</p>
            <p>Tipps:</p>
            <ul>
                <li>einfach strsplit() benutzen auf unseren Vektor/Liste</li>
            </ul>
            <p>Damit geht es dann auf der nächsten page weiter :]</p>
        </div>

        <div class="page" data-page="2">
            <h1>PFM - Seite 2</h1>
            <p>Lösung:</p>
            <pre>
split_sequences = strsplit(sequences, "")

print(split_sequences)
            </pre>
            <p>Das Format wie unsere Sequenzen da liegen, ist nicht so praktisch, wir können jetzt versuchen aus der Liste eine Matrix zu erstellen, die als rows unsere Sequenzen hat und als columns die Position. So können wir bspw. einfach über das indexen herausfinden an welcher Position welche Base in jeder Sequenz liegt. Wenn wir es geschafft haben, würde uns position_matirx[1,1] = "A" liefern.</p>
            <p>Tipps:</p>
            <ul>
                <li>probier den unlist() befehl aus</li>
                <li>wende dann auf die "unlisted" matrix() an und nimm die passende Dimension / Row anzahl</li>
            </ul>
            <p>Auf der nächsten page gibt es dann die Lösuuung</p>
        </div>

        <style>
            pre {
                background-color: #d8d8d814;
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 10px;
                font-family: 'Courier New', monospace;
                white-space: pre-wrap;
                word-wrap: break-word;
                text-align: left;
                margin: 10px 0;
                font-size: 0.8em;
                line-height: 1.4;
            }
        </style>
        
        <div class="page" data-page="3">
            <h1>PFM - Seite 3</h1>
            <p>Lösung:</p>
            <pre>
anzahl_sequenzen = length(sequences)

position_matrix = matrix(unlist(split_sequences), nrow = anzahl_sequenzen, byrow = TRUE)

print(position_matrix)
            </pre>
        <p>wooow, der nervige Teil ist jetzt geschafft unsere Daten liegen jetzt im richtigen Format vor und wir können einfacher mit ihnen arbeiten. Jetzt wollen wir eine Funktion schreiben die die Position-Matrix übergeben bekommt und eine neue Matrix zurückgibt, die als Columns unsere Basen hat und als rows die Positionen. Dafür hätte ich wieder ein Frame, den wir zusammen nacheinander auffüllen können bis wir die fertige Funktion haben :]</p>
        
        <pre>
count_frequencies = function(position_matrix) {
    basen = c("A", "C", "G", "T")
    frequency_matrix = matrix(0, nrow = ?, ncol = ?)
    
    for (pos in 1:?) {
        for (i in 1:?) {
            frequency_matrix[pos, i] = ?
        }
    }
    
    colnames(frequency_matrix) = basen
    
    return(frequency_matrix)
    }
        </pre>
        <p>Ahhh, nicht erschrecken, sieht bisschen kompliziert aus, aber es ist ganz einfach. Wir fangen erstmal an damit die frequency_matrix mit nullen aufgefüllt zu definieren. Du kannst dir hierbei überlgen, was die Anzahl an row's (nrow) und column's (ncol) sein muss.</p>
        <p>Tipps:</p>
        <ul>
            <li>length() benutzen</li>
        </ul>
        </div>

        <div class="page" data-page="4">
            <h1>PFM - Seite 4</h1>
            <p>Lösung:</p>  
            <pre>
count_frequencies = function(position_matrix) {
    basen = c("A", "C", "G", "T")
    frequency_matrix = matrix(0, nrow = ncol(position_matrix), ncol = length(basen))
    
    for (pos in 1:?) {
        for (i in 1:?) {
            frequency_matrix[pos, i] = ?
        }
    }
    
    colnames(frequency_matrix) = basen
    
    return(frequency_matrix)
    }
</pre>
            <p>Soooo, jetzt wollen wir die Matrix mithilfe von zwei for schleifen befüllen. Du musst dir vorstellen das wir bei der oberen Schleife mit pos=1 anfangen und dann die untere Schleife einmal komplett durchlaufen mit i=1, i=2,... Wir wollen also zuerst für die erste Position alle Basen durchlaufen und weiter. Du kannst dir erstmal überlegen wie wir die Grenzen setzen müssen. Alsoo, was die maximale Anzahl an Positionen (pos) ist und wo wir die Info dafür herbekommen und was die maximale Anzahl an Basen (i) ist.</p>
            <p>Tipps:</p>
            <ul>
                <li>ncol() und length() benutzen</li>
            </ul>
        </div>

        <div class="page" data-page="5">
            <h1>PFM - Seite 5</h1>
            <p>Lösung:</p>
            <pre>
count_frequencies = function(position_matrix) {
    basen = c("A", "C", "G", "T")
    frequency_matrix = matrix(0, nrow = ncol(position_matrix), ncol = length(basen))
    
    for (pos in 1:ncol(position_matrix)) {
        for (i in 1:length(basen)) {
            frequency_matrix[pos, i] = ?
        }
    }
    
    colnames(frequency_matrix) = basen
    
    return(frequency_matrix)
    }
            </pre>
            <p>okööö, jetzt wirds nicht unbedingt leichter, wir wollen jetzt unser (pos) und (i) aus den Schleifen zum befüllen nutzen.  Stell dir mal vor, die Schleife läuft nur einmal durch, d.h. pos=1 und i=1. Wir füllen also den eintrag frequency_matrix[1,1] auf, d.h wie oft kommt in Position 1 die Base "A" vor. Würde die Schleife jetzt weiterlaufen, würde frequency_matrix[1,2] dran sein, also wie oft kommt "C" an Position 1 vor und weiter bis alle Basen dran waren und dann kommt Position 2 und das ganze wiederholt sich. Puuuuh, blickst du da durch? :O. Ist ein bisschen weird wenn man mehrere Schleifen benutzt. Wir müssen uns jetzt überlegen wie genau wir jetzt entsprechend (pos) für unsere position_matrix benutzen können und (i) für unsere Basen, damit wir die Häufigkeiten berechnen können.</p>
            <p>Schauen wir uns dafür also am besten unsere Position_matrix an:</p>
            <img src="position_matrix.png" alt="Markovkette" style="margin-top: 20px; max-width: 70%; border-radius: 10px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);">
            <p>Wir sehen das wir uns immer die Spalten anschauen müssen, also position_matrix[,pos] und dort jeweils checken ob es basen[i] entspricht und falls TRUE, wollen wir das aufsummieren, das geht über sum(). Du kannst versuchen die Bedingung zu schreiben und dann wäre unsere Funktion auch fertig. Das wichtigste ist aber das du das Konzept halbwegs verstanden hast, wie wir die zwei For-Schleifen perfekt ausnutzen können.</p>
        </div>
    
        <div class="page" data-page="6">
            <h1>PFM - Seite 6</h1>
            <p>Lösung:</p>
            <pre>
count_frequencies = function(position_matrix) {
    basen = c("A", "C", "G", "T")
    frequency_matrix = matrix(0, nrow = ncol(position_matrix), ncol = length(basen))
    
    for (pos in 1:ncol(position_matrix)) {
        for (i in 1:length(basen)) {
            frequency_matrix[pos, i] = sum(position_matrix[, pos] == basen[i])
        }
    }
    
    colnames(frequency_matrix) = basen
    
    return(frequency_matrix)
}

# Testen
frequency_matrix = count_frequencies(position_matrix)
print(frequency_matrix)
            </pre>
            <p>Juhuu, jetzt haben wir eine Matrix die angibt wie Häufig die jeweilige Base an der Position vorkommt. Hoffentlich konntest du was verstehen und das war nicht zu durcheinander, ist ein bisschen schwer das über Text zu erklären, aber ja vllt. konntest du dich ein bisschen reindenken und was daraus mitnehmen und jaaa tschaaauuu :)</p>
        </div>
    

        <div class="navigation">
            <button class="nav-button" id="prevButton">Zurück</button>
            <button class="nav-button" id="nextButton">Weiter</button>
            <a href="../index.html" class="nav-button">Zum Kalender</a>
        </div>
    </div>


    <script>
        function optimizeBackgroundImage() {
        const body = document.body;
        const img = new Image();
        img.src = 'tuerchen/background.jpeg';
        
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            const windowAspectRatio = window.innerWidth / window.innerHeight;
            
            if (aspectRatio > windowAspectRatio) {
                // Wenn das Bild breiter ist als der Bildschirm
                body.style.backgroundSize = 'auto 100%';
            } else {
                // Wenn das Bild höher ist als der Bildschirm
                body.style.backgroundSize = '100% auto';
            }
        };

        // Aktualisiere bei Größenänderung des Fensters
        window.addEventListener('resize', optimizeBackgroundImage);
    }
        function createSnowflakes() {
            const snowContainer = document.getElementById('snowContainer');
            for (let i = 0; i < 100; i++) {
                const snowflake = document.createElement('div');
                snowflake.classList.add('snowflake');
                snowflake.style.left = Math.random() * 100 + 'vw';
                snowflake.style.width = Math.random() * 3 + 1 + 'px';
                snowflake.style.height = snowflake.style.width;
                snowflake.style.animationDuration = (Math.random() * 10 + 5) + 's';
                snowflake.style.animationDelay = Math.random() * -10 + 's';
                snowContainer.appendChild(snowflake);
            }
        }

        createSnowflakes();

        // Navigation Logic
        const pages = document.querySelectorAll('.page');
        const prevButton = document.getElementById('prevButton');
        const nextButton = document.getElementById('nextButton');
        let currentPage = 1;

        function updateButtons() {
            prevButton.disabled = currentPage === 1;
            nextButton.disabled = currentPage === pages.length;
        }

        function showPage(pageNumber) {
            pages.forEach(page => page.classList.remove('active'));
            document.querySelector(`[data-page="${pageNumber}"]`).classList.add('active');
            currentPage = pageNumber;
            updateButtons();
        }

        prevButton.addEventListener('click', () => {
            if (currentPage > 1) {
                showPage(currentPage - 1);
            }
        });

        nextButton.addEventListener('click', () => {
            if (currentPage < pages.length) {
                showPage(currentPage + 1);
            }
        });

        updateButtons();
    </script>
</body>
</html>
